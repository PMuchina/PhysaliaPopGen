<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Physalia-course: Population genomics</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
section.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Physalia-course: Population genomics</h1></div>
<div class="author"><h2></h2></div>
<div class="date"><h3></h3></div>
</div>
<div class="body">
<p><i>Thibault Leroy (<a href="mailto:thibault.leroy@inrae.fr">thibault.leroy@inrae.fr</a>)</i></p>
<h2 id="part-1-bioinformaticsnovember-25-2024">Part 1: Bioinformatics<br>November 25, 2024</h2>
<h3 id="general-context">General context</h3>
<p>The analysis workflow, which includes quality control (QC) of raw sequencing data, trimming, mapping to the reference genome, QC of the mapping results, and PCR deduplication, is universally applicable across various sequencing approaches. These approaches include Pool-Seq, individual sequencing with low coverage, and moderate coverage sequencing strategies. While the downstream analysis beyond SNP calling may differ depending on the experimental design and objectives, the initial steps remain consistent and form the foundation for high-quality data processing. <br>
In the example below, the initial steps are performed on data from a Pool-Seq project; however, these same steps could just as easily be applied to other datasets. Subsequently, distinct SNP calling strategies are employed to accommodate the specific characteristics of three dataset types: Pool-Seq data, low-coverage individual sequencing, and moderate-coverage individual sequencing. <br><br>
<b>IMPORTANT: Please note that there is no universal pipeline that works for all sequencing data, biological models, and research contexts! The examples provided here are for guidance. In general, default parameter values (e.g. for read mappers such as bwa mem) work for most species, but it might be needed to use some non-default parameter values depending on the context.</b><br><br></p>
<h3 id="opening-an-ssh-connection-on-a-remote-server">Opening an SSH connection on a remote server</h3>
<p>To connect to a remote server using SSH, open your terminal and use the following command:<br>
<code>ssh username@hostname</code><br><br>
To connect on the physalia cluster, we should also provide a certificate (a key for the cybersecurity), use provided by the Physalia-course team. For example, if you are “user2”, you will only need to provide the c2.pem certificate. <br>
<code>chmod 600 popgen.pem </code><br>
To connect on the server, then use the following command (if you are “user2” of course, if you are another user, adjust the command accordingly): <br>
<code>ssh -i c2.pem user2@[hostname]</code><br>
<i>NOTE: The hostname of the Physalia machine changes daily. The machine’s ID address will be provided separately via Slack.</i><br>
The cluster is expected then to ask you: “<i>Are you sure you want to continue connecting (yes/no/[fingerprint])?</i>”. Write “yes”<br>
As soon as your are connected on the cluster, please load the conda environment corresponding to the day:<br>
<code>conda activate Workshop_TL_YB_Calling<br></p>
<p>Even if we don’t need it at this stage of the course, it is already important to know how to transfer files from your computer (local) to the remote server using SCP. In this case, you should use this command from your local terminal:<br>
<code>scp -i c2.pem [myfile] user2@hostname:[PATH_TO_DIRECTORY]</code><br>
Of course [myfile] should be replaced by the name of the file you would like to send on the cluster, and the [PATH_TO_DIRECTORY] should be replaced by the exact architecture on the cluster (e.g.</p>
<p>Simularly, do transfer files from the remote server to your computer using SCP, use this command from your local terminal:<br>
<code>scp -i c2.pem user2@[hostname]:[PATH_TO_DIRECTORY]/[myfile] .</code><br>
<i>NOTE: When using scp, you need three arguments: the scp itself, followed by two locations, with each separated by a space. In the previous example, the dot at the end of the command is crucial! It signifies “the current directory” on your local machine. This ensures that the file is placed in the directory where you are currently located.</i><br>
Assuming that you are user2 and that you want to download the full directory of the cluster, use the “-r” option, e.g. <code>scp -i c2.pem -r user2@[hostname]:~/Share/Day1_bioinfo ~/Physalia-course/ </code>to download all the results in a directory Physalia-course of your own computer (if you want to create this “Physalia-course” directory, type mkdir Physalia-course to create a new directory (mkdir stands for make directory). <br><b>IMPORTANT: If you wish to download the entire repository, please wait the end of the course today to do so!</b> <br> The “~” symbol refers to your home directory. You can navigate into a folder using cd [DIRECTORY] (e.g. cd Physalia-course) and move up one level in the directory structure with “cd ..”. If you are totally unfamiliar with commands like mkdir, cd, ls, or other basic terminal functions, don’t worry! Just inform the instructors via Slack as soon as possible in order to allow us to assist you as much as possible.<br></p>
<p><b>For today, simply copy the repository from the Share directory to a folder you create in your home directory on the cluster (i.e. no need to use scp to import it to your personal computer)</b><br>
<code>cp -r ~/Share/Day1_bioinfo/ ~</code><br>
Up to step 9 of this proposal, we will focus exclusively on the oak data located in the “data-oak” directory within ~/Day1_bioinfo/. Navigate to this directory with:<br>
<code>cd ~/Day1_bioinfo/data-oak</code><br><br></p>
<h3 id="step-1-evaluating-the-reference-genome">Step 1: Evaluating the reference genome</h3>
<p>Evaluating the quality of a reference genome is a critical step before analyzing raw sequencing data, yet it is often overlooked. This is particularly true in population genomics, where many analyses rely on assumptions, such as the presence of linkage disequilibrium between highly differentiated markers and causal genes. A fragmented or low-quality reference genome not only limits the ability to generate meaningful results but also contributes to more general issues, such as misaligned reads and inaccurate variant calls. These latter biases can significantly affect the study of genetic diversity, selection, and population structure. Tools like Assemblathon enable the rapid generation of key metrics, such as contiguity (e.g. the number of contigs and N50). Additional analyses, such as examining GC content and transposable element (TE) content across the genome, also provide valuable insights. Time spent thoroughly evaluating the reference genome is always worthwhile! <br><br>
Some important summary statistics:<br>
<b>N50</b>: The length of the shortest scaffold/contig such that 50% of the genome is contained in contigs of this length or longer (after sorting scaffolds from the largest to shortest). It reflects assembly contiguity, with higher values indicating fewer, longer contigs. Higher this N50 value, better the contiguity.<br>
<b>L50</b>: The number of contigs that contribute to the N50 length, showing how fragmented the assembly is. Lower this L50 value, better the contiguity. <br>
<b>Total length</b>: The sum of all contig lengths, should be close to the expected genome size <br>
<b>Largest scaffold/contig</b>: The length of the longest scaffold/contig, showing the maximum span of continuous sequence.<br>
<b>Number of scaffold/contigs</b>: Indicates fragmentation; fewer contigs suggest better assembly. <br>
<b>GC content</b>: The percentage of guanine and cytosine bases, reflecting base composition. <br>
<b>N content</b>: The proportion of ambiguous bases (N) in the assembly, representing unresolved or low-confidence regions. High N content (e.g. &gt;1%) indicates a fragmented or incomplete genome. <br>
<i>NOTE: a contig is a continuous sequence of DNA with no gaps, assembled from overlapping reads, while a scaffold is a series of contigs ordered and oriented relative to each other, often connected by gaps (typically represented by a series of N) where the sequence is uncertain. </i><br></p>
<p>To evaluate the quality of a reference assembly with Assemblathon:<br>
<code>export PERL5LIB=/home/ubuntu/Share/software/assemblathon2-analysis/</code><br>
<code>/home/ubuntu/Share/software/assemblathon2-analysis/assemblathon_stats.pl [reference_genome.fasta]</code><br></p>
<p><i>i.e. </i><br>
<code>export PERL5LIB=/home/ubuntu/Share/software/assemblathon2-analysis/</code><br>
<code>/home/ubuntu/Share/software/assemblathon2-analysis/assemblathon_stats.pl Qrob_PM1N.fa &gt; Qrob_PM1N.fa.assemblathon.txt </code><br><br></p>
<p>Based on the Assemblathon results, how long is the assembled genome? Does its total length exceed the expected genome size for this species (0.75 Gb)? Additionally, is this assembly resolved at the chromosome level? <br><br></p>
<h3 id="step-2-downloading-sequencing-data-from-public-repositories-like-the-sra-sequence-read-archive">Step 2: Downloading sequencing data from public repositories like the SRA (Sequence Read Archive)</h3>
<p>Sometimes, raw data relevant to your research questions are already available in public repositories, meaning there is no need to do a specific experiment and get some new data. This makes it crucial to know how to efficiently download these datasets. Public databases such as NCBI’s Sequence Read Archive (SRA) and the European Bioinformatics Institute (EBI) host a wealth of genomic data that can be easily accessed. It is then possible to open fcp protocols and download the data. Knowing how to download these datasets ensures that you can make the most of existing resources and focus on advancing your research.<br>
I consider that the EBI website is more convenient to use than the one of the NBCI. Anyway, to download oak data from Leroy et al. 2020 (New Phytology), visit the website (<a href="https://www.ebi.ac.uk/ena/browser/home">https://www.ebi.ac.uk/ena/browser/home</a>) and search for PRJEB32209 in the search window at the top right. Then click on “View all 72 results”, click on one of the experiment or run and select the name(s) of the fastq.gz files you would like to download and then “Get download script”. The information you will get from this archive<br>
e.g. to download ERR3284873, the population (253 in Leroy et al. 2020), <a href="https://www.ebi.ac.uk/ena/browser/view/ERR3284873">https://www.ebi.ac.uk/ena/browser/view/ERR3284873</a> <br>
Then, you can simply run the following command in your terminal:<br>
<code>wget -nc <a href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR328/003/ERR3284873/ERR3284873_1.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR328/003/ERR3284873/ERR3284873_1.fastq.gz</a></code><br>
<code>wget -nc <a href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR328/003/ERR3284873/ERR3284873_2.fastq.gz">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR328/003/ERR3284873/ERR3284873_2.fastq.gz</a></code><br>
<b>PLEASE DO NOT EXECUTE this code today, as these fastq.gz files are very large!</b><br>
<i>Note: If you have started the download and wish to stop it, press Ctrl+C in your terminal. Ctrl+C is the command you should now in bash, it does not mean “copy”, but “stop”, it stops a job running on your console. Try to remind this, Ctrl+C has a totally different meaning in a command-line interface (shell), so do not use Ctrl+C to copy/paste!</i><br>
<b>Instead of processing extremely large files, today we will work with a limited dataset consisting of a few tens of thousands of sequencing reads (hereafter referred to as “subset”), you will find the data in the “Day1_bioinfo/data-oak/Raw-data” directory</b><br><br></p>
<h3 id="step-3-quality-control-of-raw-sequencing-data">Step 3: Quality control of raw sequencing data</h3>
<p>One of the first steps when receiving sequencing data is to assess its quality using tools like FastQC and MultiQC.<br>
FastQC provides a detailed report on various quality metrics of the raw data, such as base quality scores, GC content, adapter contamination, and sequence duplication levels. This helps identify potential issues that could affect downstream analyses.<br>
After running FastQC on each sample, we often use MultiQC to aggregate and summarize the results from multiple FastQC reports into a single, comprehensive overview. MultiQC makes it easier to spot patterns and common issues across datasets, allowing us to make informed decisions on whether additional preprocessing, such as trimming or filtering, is needed before proceeding with mapping or further analysis (although we recommend performing read trimming in all cases). Evaluating the quality control is essential to have a rapid overview of the raw sequencing data, which is a first step to ensure the reliability and accuracy of subsequent genomic analyses.<br></p>
<p>Based on the subset, you could have run the following command to investigate the quality of the reads.<br>
<code>cd Raw-data/</code><br>
<code>for i in *subset.fastq.gz; do fastqc $i; done</code><br>
<code>multiqc <em>subset</em></code><br><br></p>
<p>Download the files on your own computer (using scp, see above) and open the fastqc and the multiQC reports in your web browser to explore the results. Note that, given the computation time required to download the raw sequencing data, I have also provided the FastQC and MultiQC results for the full data (see ~/Day1_bioinfo/data-oak/Full_data/). Please note that both FastQC and MultiQC generate HTML reports, which can be only opened on your own computer. <br>
<i>Note: FastQC provides an estimate of the proportion of duplicates based on Kmer strategy, this proportion should not be overintepreted since the approach is expected to largely overestimated the proportion of duplicates, to have a more accurate estimate of duplicates, see step 7.</i><br></p>
<h3 id="step-4-read-trimming">Step 4: Read trimming</h3>
<p>Trimming is a critical preprocessing step in next-generation sequencing (NGS) data analysis that involves removing low-quality bases, adapters, and unwanted sequences (e.g. short sequences after trimming) from raw reads. This step ensures that only high-quality data is used for downstream analyses. Common issues addressed during trimming include sequencing errors at the ends of reads and residual adapter contamination, all of which can negatively impact mapping and bioinformatics pipelines, including variant detection.<br>
Trimmomatic is one of the most widely used tools for read trimming due to its flexibility and effectiveness. It supports various trimming operations tailored to the specific needs of NGS datasets.<BR><br>
Some of the most important parameters in Trimmomatic:<br>
<b>ILLUMINACLIP</b>: Removes adapter sequences using a predefined adapter file. Essential for eliminating contaminants from the sequencing process.<br>
<b>SLIDINGWINDOW</b>: Applies a sliding window approach to trim reads once the average quality score in a specified window size falls below a threshold. Helps remove low-quality regions dynamically.<br>
<b>LEADING</b>: Removes low-quality bases from the start of a read. Useful for fixing sequencing artifacts common at the 5’ end.<br>
<b>TRAILING</b>: Removes low-quality bases from the end of a read, where sequencing quality often deteriorates.<br>
<b>MINLEN</b>: Discards reads shorter than a specified length after trimming, ensuring that only informative reads are retained.<br>
<b>CROP</b>: Cuts reads to a specific length, useful for standardizing read lengths across a dataset.<br><br></p>
<p>Here an example:<br>
<code>conda deactivate</code><br>
<code>conda activate Workshop_TL_YB_Calling2</code><br>
<code>cd ~/Day1_bioinfo/data-oak/Raw-data/</code><br>
<code>for j in ERR3284869 ERR3284873 ERR3284898; do</code><br>
<code>	  acc=$(echo “./$j”)</code><br>
<code>	  outacc=$(echo “../Trimming/$j”)</code><br>
<code>	  trimmomatic PE -threads 1 -phred33 “$acc”_1.subset.fastq.gz “$acc”_2.subset.fastq.gz “$outacc”_1.cleaned.subset.fastq.gz “$outacc”_1.cleaned_unpaired.subset.fastq.gz “$outacc”_2.cleaned.subset.fastq.gz “$outacc”_2.cleaned_unpaired.subset.fastq.gz \</code><br>
<code>ILLUMINACLIP:/home/ubuntu/src/conda/envs/Workshop_TL_YB_Calling2/share/trimmomatic-0.39-2/
<code>adaptersTruSeq3-PE-2.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:50</code><br>
<code>done</code><br>
<i>Note: The script is designed to save the results in a Trimming directory. Therefore, ensure you already have a Trimming directory in the data-oak directory (normally yes, but if not, please create it with the mkdir command: “mkdir Trimming”). Additionally, remember to navigate between directories using “cd [DIRECTORY]” (e.g. cd Trimming) to enter a folder, and “cd ..” to move up one level in the directory structure! </i><br></p>
<h3 id="step-5-mapping-reads-against-a-reference-genome">Step 5: Mapping reads against a reference genome</h3>
<p>Bowtie2 and BWA-MEM are both popular tools for mapping sequencing reads to a reference genome, each with its own strengths. In most cases, the two software relatively similarly perform and be used on the same sequencing data. We could however indicate that Bowtie2 is highly efficient and flexible, particularly for aligning short to medium-length reads, and offers strong performance in handling mismatches and indels. This explains why it was more favored for RNA-seq and metagenomic datasets where these features are critical. <br>
BWA-MEM, on the other hand, is designed for longer reads, such as those generated by Illumina paired-end sequencing or third-generation platforms. It excels in accuracy for gapped alignments and complex genomic regions, making it a (bit more) preferred choice for whole-genome resequencing or structural variant studies.<br>
In this tutorial, we will focus on BWA-MEM2, an enhanced version of BWA-MEM, which offers faster alignment speeds and reduced memory usage. While Bowtie2 is a strong alternative, BWA-MEM2 is particularly suited for the type of data we will be working with.<br><br></p>
<p>Generally, to speed up computations, software requires to index the reference genome. Note that all sofware does no index the genome in the same way, so please take care to check potential errors in the logs when running new software! Using bwa-mem2, it is pretty simple to index the sequence, however it requires a lot of RAM, that’s why all the indexes are already included in the same repository than the reference genome (note that the bwa-mem2 index command is preceded by a “#”, which silences it, meaning that the command will not be executed here): <br>
<code>conda deactivate</code><br>
<code>conda activate Workshop_TL_YB_Calling</code><br>
<code>cd ~/Day1_bioinfo/data-oak/</code><br>
<code>REFERENCE_GENOME=$(echo “Qrob_PM1N.fa”)</code><br>
<code>#bwa-mem2 index $REFERENCE_GENOME </code><br><br>
Then, perform mapping for each individual:<br>
<code>cd ~/Day1_bioinfo/data-oak/Trimming</code><br>
<code>for j in ERR3284869 ERR3284873 ERR3284898; do</code><br>
<code>  acc=$(echo “$j”)</code><br>
<code>  outacc=$(echo “../Mapping/$j””_subset_trimmedPE”)</code><br>
<code>  bwa-mem2 mem ../$REFERENCE_GENOME “$acc”_1.cleaned.subset.fastq.gz “$acc”_2.cleaned.subset.fastq.gz | samtools view -Sb - &gt; $outacc.bam</code><br>
<code>done</code><br><br>
<i>Note: in this example, we will only worked on paired-end data after trimming, but it would be possible to use bwa-mem2 mem with a single fastq.file</i><br><br>
OPTIONAL: The example below demonstrates how to map paired-end data after trimming, while excluding single-end reads remaining after trimming (i.e. “cleaned_unpaired” reads). Identify the appropriate command-line to map these single-end reads.<br></p>
<p>To optimize computational efficiency, most bioinformatics software requires reads to be sorted by their genomic positions. Raw sequencing reads are random fragments of DNA sampled across the entire genome and are mapped individually to the reference genome. Sorting these mapped reads reorganizes them in sequential order, from the first to the last position of the reference genome, facilitating faster and more efficient downstream analyses. Common tools for sorting BAM files include Samtools and Picard. <br>
Here an example with picard:<br>
<code>cd ~/Day1_bioinfo/data-oak/Mapping</code><br>
<code>for i in *.bam; do </code><br>
<code>	  # Define paths and variables</code><br>
<code>	  INPUT_BAM=”$i”</code><br>
<code>	  OUTPUT_SORTED_BAM=”$i.sorted”</code><br>
<code>	  # Sort reads with SortSam</code><br>
<code>	  picard SortSam \</code><br>
<code>	  I=${INPUT_BAM} \</code><br>
<code>	  O=${OUTPUT_SORTED_BAM} \</code><br>
<code>	  SORT_ORDER=coordinate \</code><br>
<code>	  VALIDATION_STRINGENCY=LENIENT</code><br>
<code>done</code><br>
<i>Note: For large sequencing datasets, we strongly recommend deleting unnecessary files (e.g. unsorted BAM files) once they are no longer needed. This helps free up valuable storage space on your computing cluster.</i><br><br></p>
<h3 id="step-6-qc-based-on-the-results-of-mapping">Step 6: QC based on the results of mapping</h3>
<p>Performing quality control after read mapping is a critical step to assess the success of the alignment process and ensure reliable downstream analyses. Tools like Samtools flagstat and Samtools idxstats provide valuable insights into the quality and distribution of mapped reads.<br></p>
<p>Samtools flagstat summarizes key alignment statistics, such as the total number of reads, the proportion mapped to the reference genome, and the fraction of properly paired reads in paired-end reads sequencing data. These metrics help evaluate alignment efficiency and identify potential issues, such as low-quality mappings or unexpected levels of unmapped reads. As you will see below, I recommend to regularly use <br>
To use flagstat, execute the following command:<br>
<code>for i in *.sorted; do</code><br>
<code>  samtools flagstat $i &gt; $i.flagstat.txt</code><br>
<code>done</code><br>
Use the function less or more e.g. “<code>less [file].flagstat.txt</code>” to explore the results.<br>
OPTIONAL: Try to directly map the raw data (without trimming) and compare the results with flagstat. Do you observe some differences with or without trimming? <br><br></p>
<p>Samtools idxstats is another valuable tool to have an overview of the mapping. It provides per-chromosome statistics about mapped and unmapped reads relative to the length of each scaffold in the reference assembly. The output consists of four columns: scaffold name, scaffold length, the number of mapped reads, and the number of unmapped reads. However, it’s important to note that the term “unmapped reads” in this context can be somewhat misleading - it refers to reads assigned to a chromosome but with low-confidence alignments, such as low-quality mappings or secondary alignments. By analyzing the idxstats output, researchers can assess genome coverage by dividing the number of reads by the scaffold length and identify potential issues, such as uneven coverage, due to over-represented contigs or contamination. This makes idxstats an essential step in ensuring the quality and reliability of mapped sequencing data.<br>
To use idxstats, execute the following command:<br>
<code>for i in *.sorted; do</code><br>
<code>  samtools index $i</code><br>
<code>  samtools idxstats $i &gt; $i.idxstats.txt</code><br>
<code>done</code><br></p>
<h3 id="step-7-removing-pcr-duplicates">Step 7: Removing PCR duplicates</h3>
<p>Marking PCR duplicates is another essential step in sequencing data processing, particularly when dealing with whole-genome sequencing. PCR amplification during library preparation can introduce duplicates from the same DNA fragment, which can bias downstream analyses. By marking duplicates, reads with identical start and end positions are flagged, helping to identify likely PCR artifacts without removing them. This preserves all data for flexibility in later analyses, as some tools can decide to exclude duplicates based on the specific research goal.<br></p>
<p>Picard MarkDuplicates is a widely used tool for this purpose. It identifies duplicates in BAM files, marks them with a specific flag (0x400), and generates metrics to quantify the duplication rate. This approach ensures that researchers retain all information while providing the option to filter duplicates when necessary.<br></p>
<p>However, it is important to note the importance of marking duplicates can vary depending on the experimental context. For instance, in restriction enzyme-based RAD-Seq data, particularly with single-digest restriction, the start positions of the reads can be identical across different fragments, even in the absence of PCR duplicates. This can be misleading as it may appear as if there are duplicates, when in fact, they represent distinct fragments from the same restriction site. Similarly, with single-end sequencing data, the start positions of reads from different fragments can also overlap, leading to potential false positives in duplicate detection. In these cases, whether marking duplicates should be performed can be evaluated, since filtering too much data based on duplication rates could also impact the downstream analysis. To summarize, for all whole-genome sequencing projects with paired-end sequencing data, we strongly recommend to mark duplicates. For some other data, the decision to mark or remove duplicates should always be made in the context of the specific experimental design and research objectives. <br>
<b>Here, due to practical constraints associated with truncating the data to generate a subset of reads to be manageable during the course, we are unable to run the Picard MarkDuplicates command directly.</b> However, the command shown below was applied to the full dataset:<br>
<code>for i in *.bam; do</code><br>
<code>  # Define paths and variables</code><br>
<code>  INPUT_SORTED_BAM=”$i.sorted”</code><br>
<code>  OUTPUT_BAM=”$i.dedup”</code><br>
<code>  METRICS_FILE=”$i.duplication_metrics.txt”</code><br>
<code>  TMP_DIR=“bidontmp”</code><br>
<code>  # Run Picard MarkDuplicates</code><br>
<code>  picard MarkDuplicates &lt;/code&gt;<br>
<code>  I=${INPUT_SORTED_BAM} \</code><br>
<code>  O=${OUTPUT_BAM} \</code><br>
<code>  M=${METRICS_FILE} \</code><br>
<code>  REMOVE_DUPLICATES=false \</code><br>
<code>  ASSUME_SORTED=true \</code><br>
<code>  VALIDATION_STRINGENCY=LENIENT</code><br>
<code>done</code><br><br>
The MarkDuplicates output files (i.e. “duplication_metrics.txt” in the command above) are available in the “./data-oak/Full_data/” respository for both paired-end and single-end reads after trimming and provides key information about PCR duplicates in the sequencing data, including a histogram that shows the distribution of duplicate groups based on the number of reads in each group (e.g. pairs, triplicates). The most important information is the percentage of duplicates relative to the total number of duplicates detected and mapped reads. This percentage is crucial for assessing the extent of PCR duplication in your dataset. A high percentage of duplicates may indicate excessive PCR amplification during library preparation, which could bias downstream analyses, such as variant calling or coverage estimation. Monitoring this value helps determine if duplicate removal or marking is necessary for your analysis.<br></p>
<p>Compare the proportion of duplicates identified in the MarkDuplicates output with the corresponding values reported in the MultiQC report. Are the results consistent? <br>
Do you expect any differences if you use samtools flagstat on the BAM files after deduplication? <br><br></p>
<h3 id="step-8-allele-counts-amp-mpileup-files-for-pool-seq-data">Step 8: Allele counts &amp; mpileup files for pool-seq data</h3>
<p>Using mpileup for pool-seq data allows you to generate a compact representation of sequence data at each position across multiple pools, providing depth and allele information. It helps identify variation and detect the presence of specific alleles across different samples. <br></p>
<p>Here again, due to the constraints associated with the cluster, the commands below are only provided (PLEASE DO NOT EXECUTE THEM):<br>
<code>samtools mpileup -f ../../Qrob_PM1N.fa -q 20 -Q 30 \</code><br>
<code>ERR3284869ERR3284873_subset_trimmedPE.bam.dedup \</code><br>
<code>ERR3284873ERR3284873_subset_trimmedPE.bam.dedup \</code><br>
<code>ERR3284898ERR3284873_subset_trimmedPE.bam.dedup \</code><br>
<code> &gt; ../Calling/Oak_3pools.mpileup</code><br>
Explanations: <br>
-q 20 corresponds to the minimum base quality score for including bases in the mpileup <br>
-Q 30 corresponds to the minimum mapping quality for including reads in the mpileup <br><br>
The mpileup output is expected to include the following columns: chromosome, position, reference allele (from the reference assembly), read depth for pool 1, sequenced alleles for pool 1 (where “.” indicates that the sequenced allele is the same than the one on the reference genome), and base quality for pool 1. This is followed by the same information for pool 2, and then for pool 3, respectively.<br>
<code>Qrob_Chr01	1	T	0	*	*	1	^8.		C		0	*	*</code><br>
<code>Qrob_Chr01	2	C	0	*	*	1	.		C		0	*	*</code><br>
<code>Qrob_Chr01	3	T	0	*	*	1	.		C		0	*	*</code><br>
<code>Qrob_Chr01	4	G	0	*	*	2	.^9.	F@		0	*	*</code><br>
<code>Qrob_Chr01	5	A	0	*	*	2	..		F@		0	*	*</code><br>
<code>Qrob_Chr01	6	A	0	*	*	3	G.^8.	F@C		1	^7.	@</code><br>
<code>Qrob_Chr01	7	G	0	*	*	3	A..		FFC		3	…	FF@</code><br>
<code>Qrob_Chr01	8	T	0	*	*	4	...^8.	FD@@	3	…	EFB</code><br>
<code>Qrob_Chr01	9	A	0	*	*	3	...		HEF		3	…	FHD</code><br>
<code>Qrob_Chr01	10	T	0	*	*	4	....	HFF@	3	…	HHF</code><br></p>
<p>Mpileup can generate very large files, one relevant strategy to summarize this information is to convert to a syn file from the Popoolation2 suite. When converted to a synchronized format, the format is optimized for handling large-scale pooled data, allowing for accurate comparisons between pools, controlling for coverage biases, and improving the accuracy of allele frequency estimates in diverse populations.<br></p>
<p>Note that it is very easy to extract depth of coverage from a mpileup, e.g.:<br>
<code>awk ‘{print $1”\t”$2”\t”$4”\t”$7”\t”$10}’ Oak_3pools.mpileup.first100kb &gt; Oak_3pools.mpileup.first100kb.cov</code><br></p>
<p>Anyway, a mpileup can then be summarized in a synchronized mpileup with popoolation2, please use the command below: <br>
<code>mpileup2sync.pl --fastq-type sanger --input Oak_3pools.mpileup.first100kb --output Oak_3pools.mpileup.first100kb.sync</code><br></p>
<p>Here is an example of the beginning of a synchronized mpileup file: <br>
<code>Qrob_Chr01	1	T	0:0:0:0:0:0	0:1:0:0:0:0	0:0:0:0:0:0</code><br>
<code>Qrob_Chr01	2	C	0:0:0:0:0:0	0:0:1:0:0:0	0:0:0:0:0:0</code><br>
<code>Qrob_Chr01	3	T	0:0:0:0:0:0	0:1:0:0:0:0	0:0:0:0:0:0</code><br>
<code>Qrob_Chr01	4	G	0:0:0:0:0:0	0:0:0:2:0:0	0:0:0:0:0:0</code><br>
<code>Qrob_Chr01	5	A	0:0:0:0:0:0	2:0:0:0:0:0	0:0:0:0:0:0</code><br>
<code>Qrob_Chr01	6	A	0:0:0:0:0:0	2:0:0:1:0:0	1:0:0:0:0:0</code><br>
<code>Qrob_Chr01	7	G	0:0:0:0:0:0	1:0:0:2:0:0	0:0:0:3:0:0</code><br>
<code>Qrob_Chr01	8	T	0:0:0:0:0:0	0:4:0:0:0:0	0:3:0:0:0:0</code><br>
<code>Qrob_Chr01	9	A	0:0:0:0:0:0	3:0:0:0:0:0	3:0:0:0:0:0</code><br>
<code>Qrob_Chr01	10	T	0:0:0:0:0:0	0:4:0:0:0:0	0:3:0:0:0:0</code><br>
<i>Note: For each pool, the format is A-count:T-count:C-count:G-count:N-count:*-count, which represents the number of reads supporting the alleles A, T, C, G, ambigious allele (N) and indels (*).</i><br></p>
<p>Can you identify potential mutations in this output? How accurate are the mutations listed above? Explore the file further to uncover additional mutations. <br></p>
<p>Once the data is formatted, it can easily be imported into the R package poolfstat using the function popsync2pooldata. This makes it easier to call variants and perform downstream analyses adapted for pool-seq data using the functions of this R package (e.g. PCA, F[ST] calculations, etc.). For further details on these steps, please refer to Friday’s proposal.<br><br></p>
<h3 id="step-9-snp-calling-and-vcf-files-for-calling-genotypes-moderate-coverage-data">Step 9: SNP calling and vcf files for calling genotypes (moderate coverage data)</h3>
<p>Two softwares are particularly used for variant calling in moderate coverage sequencing (e.g. 10–30x): GATK and FreeBayes. In the section below, we will provide information about how to use GATK. In our case, GATK is highly suitable, since GATK is particularly ideal for population-scale studies. In brief, its HaplotypeCaller engine reconstructs haplotypes, improving accuracy for SNPs and indels, even in complex or repetitive regions. GATK’s joint genotyping via GVCF files has good sensitivity across samples. It also supports quality recalibration, reducing errors and improving reliability (this will however not be covered today). GATK however requires relatively large computational resources, but the workflows are well-documented and is used by a broad community in the field.<br></p>
<p>Although GATK and Freebayes have different specificities. Compared to FreeBayes, GATK is a bit more precise in identifying variants in complex regions and multi-allelic sites. FreeBayes, however, is faster and simpler, making it useful for quick analyses. For projects demanding accuracy and robustness, especially with moderate coverage, GATK remains the preferred choice, while FreeBayes is advantageous/more convenient for some specific data (e.g. non-diploid species) and when the availability of computational resources is more constraint.<br></p>
<p>Again, the project starts by indexing the reference <br>
<code>cd ~/Day1_bioinfo/data-datepalm/</code><br>
<code>REFERENCE=$(echo “GCF_009389715.1_palm_55x_up_171113_PBpolish2nd_filt_p_genomic.fna”)</code><br>
<code>samtools faidx $REFERENCE</code> <br>
<code>gatk CreateSequenceDictionary -R $REFERENCE</code> <br></p>
<p>With GATK, it is essential to assign distinct Read Group information for each individual. The recommended approach is to use the AddOrReplaceReadGroups function. Specifically, the individual’s name should be specified in both the RGID (Read Group ID) and RGSM (Read Group Sample) tags in the command below. This ensures proper identification and differentiation of samples during downstream analysis <br>
<code>cd Mapping</code><br>
<code>for i in *.bam; do</code><br>
<code>  name=$(basename “$i” “.bam” | sed ‘s/subset_//g’)</code><br>
<code>  gatk AddOrReplaceReadGroups \</code><br>
<code>   -I subset_”$name”.bam  \</code><br>
<code>   -O subset_”$name”.RG.bam  \</code><br>
<code>   --RGID “$name”  \</code><br>
<code>   --RGLB lib1 \</code><br>
<code>   --RGPL ILLUMINA \</code><br>
<code>   --RGPU unit1 \</code><br>
<code>   --RGSM “$name”</code><br>
<code>done</code></p>
<p>GATK requires that all bam are indexed.<br>
<code>for i in *RG.bam; do </code><br>
<code>  samtools index $i</code><br>
<code>done</code><br></p>
<p>With GATK, the first step is to use the HaplotypeCaller to generate a GVCF file for each individual. This intermediate file format allows for efficient joint genotyping across multiple samples in subsequent steps. <br>
<code>cd ~/Day1_bioinfo/data-datepalm/</code><br>
<code>for bam in subset_Dayri.RG.bam subset_Halawy.RG.bam subset_Hayany.RG.bam subset_Khisab.RG.bam subset_Medjool.RG.bam; do</code><br>
<code>  rootname=$(basename “$bam” “.RG.bam”)</code><br>
<code>  gatk HaplotypeCaller \</code><br>
<code>  -R “$REFERENCE” \</code><br>
<code>  -I ./Mapping/$bam \</code><br>
<code>  -O ./Calling/$rootname.g.vcf.gz \</code><br>
<code>  -ERC GVCF</code><br>
<code>  -L -L NC_052395.1:1-24100000</code><br>
<code>done</code><br>
<i>Note: In the code above, we used the “-L” option to target a specific region of a scaffold, which helps to speed up the computations. Without this option, the .g.vcf.gz files would be generated for the entire genome. Despite targeting only a small region of the genome, the process still took several minutes to complete for the five individuals.</i><br></p>
<p>The second step below involves using CombineGVCFs to merge the individual GVCF files into a single file, preparing the data for joint genotyping across all samples. <br>
<code>gatk CombineGVCFs -R $REFERENCE \</code><br>
<code>  --variant ./Calling/subset_Dayri.g.vcf.gz \</code><br>
<code>  --variant ./Calling/subset_Halawy.g.vcf.gz \</code><br>
<code>  --variant ./Calling/subset_Hayany.g.vcf.gz \</code><br>
<code>  --variant ./Calling/subset_Khisab.g.vcf.gz \</code><br>
<code>  --variant ./Calling/subset_Medjool.g.vcf.gz \</code><br>
<code>-O ./Calling/datepalm.combine.NC_052395.1.g.vcf.gz</code><br></p>
<p>Then, use GenotypeGVCFs to perform joint genotyping on the combined GVCF file, producing a multisample VCF file with the identified variants across all individuals. <br>
<code>gatk GenotypeGVCFs \</code><br>
<code>  -R $REFERENCE \</code><br>
<code>  -V ./Calling/datepalm.combine.NC_052395.1.g.vcf.gz \</code><br>
<code>  -O ./Calling/datepalm.NC_052395.1.jointvcf.gz</code><br></p>
<p>Lastly, apply VariantFiltration to filter the raw VCF file based on quality metrics (e.g. QD, FS) to retain high-confidence variants suitable for downstream analysis.<br>
<code>gatk VariantFiltration \</code><br>
<code>  -R $REFERENCE \</code><br>
<code>  -V ./Calling/datepalm.NC_052395.1.jointvcf.gz \</code><br>
<code>  -O ./Calling/datepalm.NC_052395.1.jointvcf.filtered.gz \</code><br>
<code>  --filter-expression “QD &lt; 2.0 || FS &gt; 60.0 || MQ &lt; 40.0” \</code><br>
<code>  --filter-name “LowQual”</code><br></p>
<p><b>QD</b> means Quality by Depth and filters variants with low confidence relative to sequencing depth.<br>
<b>FS</b> means Fisher Strand Bias and detect strand bias, consistent systematic error in sequencing reads.<br>
<b>MQ </b>means Mapping Quality and ensures that calling is based on high-confidence alignments.<br>
It is possible to use more filters, e.g. <b>MQRankSum</b> (Mapping Quality Rank Sum Test), <b>ReadPosRankSum</b> (Read Position Rank Sum Test), <b>SOR</b> (Strand Odds Ratio), <b>DP</b> (Read Depth), etc.<br></p>
<p>All outputs on this section (from individual g.vcf to final filtered variants) are based on the VCF format.<br>
he VCF header begins with multiple lines starting with ##. These lines contain valuable metadata, detailing how to interpret the VCF file, including information about the commands and tools used in the pipeline, as well as annotations and parameters applied during variant calling. <br>
<code>##fileformat=VCFv4.2</code><br>
<code>##ALT=&lt;ID=NON_REF,Description=“Represents any possible alternative allele not already represented at this location by REF and ALT”&gt;</code><br>
<code>##FILTER=&lt;ID=LowQual,Description=“Low quality”&gt;</code><br>
<code>##FORMAT=&lt;ID=AD,Number=R,Type=Integer,Description=“Allelic depths for the ref and alt alleles in the order listed”&gt;</code><br>
<code>##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description=“Approximate read depth (reads with MQ=255 or with bad mates are filtered)”&gt;</code><br>
<code>##FORMAT=&lt;ID=GQ,Number=1,Type=Integer,Description=“Genotype Quality”&gt;</code><br></p>
<p>The most critical line of the VCF header is typically the last one, as it introduces the column names for the variant data. For example, in the final VCF file, this line includes standard fields such as #CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, and FORMAT, followed by the names of the individual samples. This structure is essential for understanding and interpreting the variant information for each sample.<br> Using grep, it is easy to recover this information:
<code>zmore datepalm.jointvcf.filtered.gz | grep “#CHROM” </code><br></p>
<p>How many columns do you observe in your vcf? Does this correspond to your expectation?<br></p>
<p>How many low-quality (“LowQual”) and high-quality (“PASS”) variants are present in your VCF? To answer this, use tools like grep (=find) and wc -l (=count).<br></p>
<p>OPTIONAL: Count the number of homozygous and heterozygous genotypes for each individual, along with the number of missing calls. <br>
<i>Note: Historically, GenotypeGVCFs represented missing genotypes as a . in the VCF output (e.g. “./.” calls for diploids). However, if you are using GATK versions 4.2.3.0 through 4.5.0.0, missing genotypes are indicated as 0/0 with an associated read depth (DP) of zero. This change caused confusion in the community, leading GATK to revert to using dots for missing genotypes in subsequent versions.</i></p>
<h3 id="step-10-genotype-likelihood-low-coverage-data">Step 10: Genotype likelihood (low coverage data)</h3>
<p>This section of the analysis presents additional challenges due to the significant computational load required to process the data. For this reason, the provided commands are included primarily as an indicative reference rather than for direct execution. <br></p>
<p>The use of ANGSD (Analysis of Next-Generation Sequencing Data) is particularly valuable in scenarios with low-coverage sequencing data. Traditional methods for population genomic analyses often rely on high-confidence genotype calls, which are difficult to obtain when sequencing depth is limited. ANGSD, however, allows analyses to be performed directly on genotype likelihoods instead of called genotypes. This approach leverages probabilistic models to handle uncertainties inherent in low-coverage data effectively. <br></p>
<p>In this section, we will perform genotype calling for a set of samples collected from green anole lizards inhabiting urban and non-urban environments. For further details and context, please refer to Thursday’s practical session. <br></p>
<p>First, index the reference genome using the following commands: <br>
<code>cd ~/Day1_bioinfo/data-anole/</code><br>
<code>samtools faidx anoCar2.fa</code><br>
<code>gatk CreateSequenceDictionary -R anoCar2.fa</code><br></p>
<p>Then, generate a full list of samples:<br>
<code>cat subset_urban.list countryside.list &gt; urban_countryside.list</code><br>
<code>sed ‘s;subset;./Mapping/subset;g’ urban_countryside.list &gt; urban_countryside.path.list</code><br></p>
<p>Now it is time to perform the calling with ANGSD <br></p>
<p><code>angsd -bam urban_countryside.path.list \</code><br>
<code>  -ref anoCar2.fa \</code><br>
<code>  -out ./Calling/urban_contryside_anole \</code><br>
<code>  -GL 1 \</code><br>
<code>  -doMajorMinor 1 \</code><br>
<code>  -doMaf 1 \</code><br>
<code>  -doBcf 1 \</code><br>
<code>  -doGlf 2 \</code><br>
<code>  -doCounts 1 \</code><br>
<code>  -P 2 \</code><br>
<code>  -minMapQ 30 \</code><br>
<code>  -minQ 20 \</code><br>
<code>  -baq 1 \</code><br>
<code>  -uniqueOnly 1 \</code><br>
<code>  -remove_bads 1 \</code><br>
<code>  -setMinDepth 3 \</code><br>
<code>  -setMaxDepth 100</code><br></p>
<p><b><i>Since the command above will take approximately 10 minutes to execute, you have enough time to read through the important information provided below!</i></b><br></p>
<p>In the command above, the parameters correspond to:<br><br />
<b>-bam</b>: specify the input BAM files for the calling <be>
<b>-out</b>: define the output file name prefix <br>
<b>-ref</b>: specify the reference genome to use <br>
<b>-GL</b>: define the methods to use to estimate likelihood calculation (1=samtools model,2=GATK model, etc). <br>
<b>-doMajorMinor</b>: this function identifies the major (most frequent) and minor (less frequent) alleles at each site based on read counts and calculates their frequencies. <br>
<b>-doMaf</b>: computes minor allele frequency for each site.<br>
<b>-doBcf</b>: outputs a BCF file containing genotype likelihood<br>
<b>-doGlf</b>: outputs other format for genotype likelihood files (see ANGSD documentation)<br>
<b>-doThetas</b>: Estimates population-level nucleotide diversity (θ).<br>
<b>-doCounts</b>: Generates read depth and base counts at each site, which can be useful for evaluating the quality of the sequencing and variant calls.<br>
<b>-P</b>: Specifies the number of threads to use for parallel processing.<br>
<b>-minMapQ</b>: Filters out reads with a mapping quality below a given value (e.g. 30), commonly done to improve the reliability of variant calls.<br>
<b>-minQ</b>: Sets the minimum base quality threshold to a given value (e.g. 20). Bases below this quality will be excluded from analysis to reduce errors.<br>
<b>-baq 1</b>: Applies base alignment quality (BAQ) correction, which helps to correct for mismapped reads in regions with complex alignment patterns.<br>
<b>-uniqueOnly 1</b>: Only considers uniquely mapped reads, excluding those that are ambiguously mapped.<br>
<b>-remove_bads 1</b>: Excludes bad reads that have a low mapping quality or are otherwise unreliable.<br>
<b>-setMinDepth</b>: Sets the minimum read depth required to call a variant. Variants with fewer than this number of reads are excluded.<br>
<b>-setMaxDepth 100</b>: Sets the maximum read depth allowed at a site (prevent over-representation of specific regions).<br></p>
<p>Then it is possible to transform the bcf file in a vcf file with bcftools: <br>
<code>cd ~/Day1_bioinfo/data-anole/Calling/</code><br>
<code>conda deactivate</code><br>
<code>conda activate Workshop_TL_YB_Calling2</code><br>
<code>bcftools convert -O v -o urban_contryside_anole.vcf urban_contryside_anole.bcf</code><br></p>
<p>It is convenient to explore the VCF<br>
<code>grep -v “#” urban_contryside_anole.vcf | head -30000 | tail -2</code><br>
<code>chr4	120457343	.	T	G	.	PASS	NS=23;DP=60;AF=2.62007e-06	DP:GL:PL:GP	2:0,-0.602068,-7.29999:0,6,73:0.800003,0.199997,4.00962e-08	0:0,0,0:0,0,0:0.333333,0.333333,0.333333 <i>(…continued)</i><br></code><br>
<code>chr4	120457344	.	G	T	PASS	NS=26;DP=92;AF=0.0170235	DP:GL:PL:GP	4:0,-1.20414,-10.6139:0,12,106:0.941178,0.0588216,2.2899e-11	0:0,0,0:0,0,0:0.333333,0.333333,0.333333 <i>(…continued)</i><br></code><br></p>
<p>Interpret the results for the two positions displayed in the VCF above (or any other selected positions from the VCF). What are the most likely genotype calls at these positions? Do the results appear logical and consistent with your expectations? <br></p>
<p>By using ANGSD, it is possible to estimate allele frequencies, compute diversity statistics, and even detect signals of selection while accommodating the limitations of low-depth sequencing. These capabilities make it an essential tool for population genomic studies where resources or biological constraints restrict sequencing coverage (see Thursday’s practical session). <br></p>
</div>
</body>
</html>
